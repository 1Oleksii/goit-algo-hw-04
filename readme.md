# Висновки щодо ефективності алгоритмів сортування

У цьому домашньому завданні було проведено порівняння трьох алгоритмів сортування:  
- Вставками (Insertion Sort)  
- Злиттям (Merge Sort)  
- Вбудований алгоритм Python (Timsort)

## Результати тестування

Було протестовано три обсяги даних: 100, 1000 та 5000 елементів. Час вимірювався як середній результат 5 запусків для кожного алгоритму.

| Розмір даних | Insertion Sort (сек) | Merge Sort (сек) | Timsort (сек) |
|--------------|---------------------|-----------------|---------------|
| 100          | 0.001056            | 0.000840        | 0.000029      |
| 1000         | 0.121272            | 0.012386        | 0.000387      |
| 5000         | 2.794805            | 0.070919        | 0.002323      |

## Висновки

- **Insertion Sort** показав найгірші результати при збільшенні розміру масиву, що відповідає його квадратичній складності O(n²).  
- **Merge Sort** значно швидший завдяки складності O(n log n), добре підходить для великих наборів даних.  
- **Timsort** (вбудований алгоритм Python) найшвидший серед усіх, завдяки оптимізаціям для реальних даних та адаптивній природі.

Таким чином, для малих обсягів даних можна використовувати прості алгоритми, як Insertion Sort, а для більших — Merge Sort або Timsort. Для практичних задач на Python оптимальним вибором є вбудований `sorted()` (Timsort).

